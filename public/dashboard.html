<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard Estufa Inteligente</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.0.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.2.0"></script>
  <style>
    :root {
      --bg: #121212;
      --text: #e0e0e0;
      --card-bg: #1e1e1e;
      --button-bg: #4CAF50;
      --button-text: #fff;
      --canvas-bg: #1a1a1a;
      --border: #444;
      --input-bg: #333;
      --input-border: #555;
      --toggle-bg-off: #ccc;
      --toggle-bg-on: #4CAF50;
    }

    body.light {
      --bg: #f4f4f4;
      --text: #333;
      --card-bg: #fff;
      --button-bg: #4CAF50;
      --button-text: #fff;
      --canvas-bg: #fff;
      --border: #ddd;
      --input-bg: #f8f8f8;
      --input-border: #ddd;
      --toggle-bg-off: #999;
      --toggle-bg-on: #388E3C;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      transition: background 0.3s, color 0.3s;
    }

    .container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      width: 100%;
      max-width: 1200px;
      margin-top: 20px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transition: background 0.3s, border-color 0.3s, box-shadow 0.3s;
    }

    h1 {
      color: var(--text);
      text-align: center;
      margin-bottom: 25px;
      font-size: 2.2em;
    }

    h2 {
      color: var(--text);
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.6em;
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
    }

    .sensor-data p, .actuator-status p, .params-form div, .history-log p {
      margin-bottom: 10px;
      font-size: 1.1em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .status-indicator {
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 6px;
      min-width: 60px;
      text-align: center;
    }

    .status-on {
      background-color: #28a745;
      color: white;
    }

    .status-off {
      background-color: #dc3545;
      color: white;
    }

    .chart-container {
      background: var(--canvas-bg);
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      border: 1px solid var(--border);
    }

    canvas {
      max-width: 100%;
      height: 300px; /* Altura fixa para os gráficos */
    }

    .button, button {
      background: var(--button-bg);
      color: var(--button-text);
      border: none;
      border-radius: 8px;
      padding: 12px 20px;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
      text-decoration: none; /* For <a> tags styled as buttons */
      display: inline-block; /* For <a> tags styled as buttons */
      text-align: center; /* For <a> tags styled as buttons */
    }

    .button:hover, button:hover {
      background: #388E3C;
      transform: translateY(-2px);
    }

    .button:active, button:active {
      transform: translateY(0);
    }

    .params-form input[type="number"] {
      width: 100px;
      padding: 8px;
      border: 1px solid var(--input-border);
      border-radius: 5px;
      background: var(--input-bg);
      color: var(--text);
      margin-left: 10px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--toggle-bg-off);
      transition: .4s;
      border-radius: 34px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: var(--toggle-bg-on);
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }

    .full-width {
        grid-column: 1 / -1; /* Ocupa todas as colunas disponíveis */
    }

    .button-group {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        flex-wrap: wrap;
        justify-content: center;
    }

    #themeToggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background 0.3s, color 0.3s, border-color 0.3s;
    }
    #themeToggle:hover {
      background: var(--border);
    }

    @media (max-width: 768px) {
        .container {
            grid-template-columns: 1fr;
        }
    }
  </style>
</head>
<body>
  <h1>Dashboard da Estufa Inteligente</h1>
  <button id="themeToggle">Alternar para Tema Claro</button>

  <div class="container">
    <!-- Dados Atuais dos Sensores -->
    <div class="card sensor-data">
      <h2>Dados Atuais dos Sensores</h2>
      <p>Temperatura: <span id="currentTemp">--</span> °C</p>
      <p>Umidade do Ar: <span id="currentHum">--</span> %</p>
      <p>Umidade do Solo: <span id="currentSoil">--</span> %</p>
    </div>

    <!-- Status dos Atuadores -->
    <div class="card actuator-status">
      <h2>Status dos Atuadores</h2>
      <p>Ventilador: <span id="ventStatus" class="status-off">OFF</span></p>
      <p>Bomba de Irrigação: <span id="irrigStatus" class="status-off">OFF</span></p>
      <p>Iluminação/Aquecedor: <span id="lightStatus" class="status-off">OFF</span></p>
      <div class="button-group">
        <button onclick="sendActuatorCommand('vent', 'on')">Ventilar ON</button>
        <button onclick="sendActuatorCommand('vent', 'off')">Ventilar OFF</button>
        <button onclick="sendActuatorCommand('irrig', 'pulse1s')">Irrigar 1s</button>
        <button onclick="sendActuatorCommand('heat', 'on')">Aquecer ON</button>
        <button onclick="sendActuatorCommand('heat', 'off')">Aquecer OFF</button>
      </div>
    </div>

    <!-- Parâmetros de Controle -->
    <div class="card params-form">
      <h2>Parâmetros de Controle</h2>
      <div>
        <label for="tempThreshold">Temp. Máx (°C):</label>
        <input type="number" id="tempThreshold" value="25.0" step="0.1">
      </div>
      <div>
        <label for="minTempThreshold">Temp. Mín (°C):</label>
        <input type="number" id="minTempThreshold" value="18.0" step="0.1">
      </div>
      <div>
        <label for="humThreshold">Umid. Máx Ar (%):</label>
        <input type="number" id="humThreshold" value="70.0" step="0.1">
      </div>
      <div>
        <label for="soilThreshold">Umid. Mín Solo (%):</label>
        <input type="number" id="soilThreshold" value="30" step="1">
      </div>
      <div>
        <span>Controle Automático:</span>
        <label class="toggle-switch">
          <input type="checkbox" id="autoControlToggle">
          <span class="slider"></span>
        </label>
      </div>
      <div class="button-group">
        <button onclick="saveParams()">Salvar Parâmetros</button>
        <button onclick="loadParams()">Recarregar Parâmetros</button>
      </div>
    </div>

    <!-- Histórico de Atuadores -->
    <div class="card history-log">
      <h2>Histórico de Atuadores</h2>
      <div id="actuatorHistoryList" style="max-height: 200px; overflow-y: auto; font-size: 0.9em;">
        <!-- Logs serão carregados aqui -->
        <p>Carregando histórico...</p>
      </div>
      <div class="button-group">
          <button onclick="loadActuatorHistory()">Atualizar Histórico</button>
      </div>
    </div>

    <!-- Gráfico de Sensores -->
    <div class="card full-width">
      <h2>Leitura dos Sensores (Últimas 48h)</h2>
      <div class="chart-container">
        <canvas id="sensorChart"></canvas>
      </div>
    </div>

    <!-- NOVO: Seção de Exportação -->
    <div class="card full-width">
        <h2>Exportar Dados</h2>
        <p>Exporte o histórico completo de dados para análise offline.</p>
        <div class="button-group">
            <a href="/api/export/sensor-data" class="button" download="sensor_data.csv">Exportar Dados dos Sensores (CSV)</a>
            <a href="/api/export/actuator-history" class="button" download="actuator_history.csv">Exportar Histórico Atuadores (CSV)</a>
        </div>
    </div>
  </div>

  <script>
    const serverUrl = window.location.origin; // Usa a URL atual do servidor
    const ws = new WebSocket(`wss://${window.location.hostname}`); // Conexão WebSocket para Railway

    let sensorChart;
    let currentParams = {}; // Para armazenar os parâmetros atuais

    // Função para enviar comandos de atuadores via WebSocket
    function sendActuatorCommand(actuator, action) {
      if (ws.readyState === WebSocket.OPEN) {
        const command = { type: 'command', actuator, action };
        ws.send(JSON.stringify(command));
        console.log('Comando WS enviado:', command);
      } else {
        alert('WebSocket não conectado. Não foi possível enviar comando.');
      }
    }

    // Função para buscar e exibir os dados mais recentes dos sensores
    async function fetchData() {
      try {
        const response = await fetch(`${serverUrl}/api/data`);
        const data = await response.json();

        if (data && data.length > 0) {
          const latest = data[data.length - 1];
          document.getElementById('currentTemp').textContent = latest.temperature.toFixed(1);
          document.getElementById('currentHum').textContent = latest.humidity.toFixed(1);
          document.getElementById('currentSoil').textContent = latest.soil.toFixed(0);

          updateChart(data); // Atualiza o gráfico com todos os dados
          // updateActuatorStatus(latest); // Não mais necessário, ESP32 controla o estado
        } else {
          document.getElementById('currentTemp').textContent = '--';
          document.getElementById('currentHum').textContent = '--';
          document.getElementById('currentSoil').textContent = '--';
          updateChart([]); // Limpa o gráfico se não houver dados
        }
      } catch (error) {
        console.error('Erro ao buscar dados dos sensores:', error);
        document.getElementById('currentTemp').textContent = 'Erro';
        document.getElementById('currentHum').textContent = 'Erro';
        document.getElementById('currentSoil').textContent = 'Erro';
      }
    }

    // Função para atualizar o gráfico
    function updateChart(data) {
        // Formata os dados para o Chart.js
        const labels = data.map(entry => luxon.DateTime.fromISO(entry.timestamp).toFormat('HH:mm:ss'));
        const temperatures = data.map(entry => entry.temperature);
        const humidities = data.map(entry => entry.humidity);
        const soils = data.map(entry => entry.soil);

        if (!sensorChart) {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            sensorChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Temperatura (°C)',
                            data: temperatures,
                            borderColor: '#FF6384',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            fill: true,
                            tension: 0.3
                        },
                        {
                            label: 'Umidade do Ar (%)',
                            data: humidities,
                            borderColor: '#36A2EB',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            fill: true,
                            tension: 0.3
                        },
                        {
                            label: 'Umidade do Solo (%)',
                            data: soils,
                            borderColor: '#FFCE56',
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            fill: true,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'category',
                            title: {
                                display: true,
                                text: 'Hora',
                                color: 'var(--text)'
                            },
                            ticks: {
                                color: 'var(--text)'
                            },
                            grid: {
                                color: 'var(--border)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Valor',
                                color: 'var(--text)'
                            },
                            ticks: {
                                color: 'var(--text)'
                            },
                            grid: {
                                color: 'var(--border)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'var(--text)'
                            }
                        }
                    }
                }
            });
        } else {
            sensorChart.data.labels = labels;
            sensorChart.data.datasets[0].data = temperatures;
            sensorChart.data.datasets[1].data = humidities;
            sensorChart.data.datasets[2].data = soils;
            sensorChart.update();
        }
    }

    // Função para salvar parâmetros no servidor
    async function saveParams() {
      const params = {
        tempThreshold: parseFloat(document.getElementById('tempThreshold').value),
        minTempThreshold: parseFloat(document.getElementById('minTempThreshold').value),
        humThreshold: parseFloat(document.getElementById('humThreshold').value),
        soilThreshold: parseInt(document.getElementById('soilThreshold').value),
        autoControl: document.getElementById('autoControlToggle').checked
      };

      try {
        const response = await fetch(`${serverUrl}/api/params`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(params)
        });
        const result = await response.json();
        if (response.ok) {
          alert('Parâmetros salvos com sucesso!');
          loadParams(); // Recarrega para garantir que o dashboard reflita o estado do servidor
        } else {
          alert('Erro ao salvar parâmetros: ' + result.error);
        }
      } catch (error) {
        console.error('Erro ao salvar parâmetros:', error);
        alert('Erro de conexão ao salvar parâmetros.');
      }
    }

    // Função para carregar parâmetros do servidor
    async function loadParams() {
      try {
        const response = await fetch(`${serverUrl}/api/params`);
        currentParams = await response.json();

        document.getElementById('tempThreshold').value = currentParams.tempThreshold;
        document.getElementById('minTempThreshold').value = currentParams.minTempThreshold;
        document.getElementById('humThreshold').value = currentParams.humThreshold;
        document.getElementById('soilThreshold').value = currentParams.soilThreshold;
        document.getElementById('autoControlToggle').checked = currentParams.autoControl;
      } catch (error) {
        console.error('Erro ao carregar parâmetros:', error);
        alert('Erro ao carregar parâmetros do servidor.');
      }
    }

    // Função para carregar e exibir o histórico de atuadores
    async function loadActuatorHistory() {
        try {
            const response = await fetch(`${serverUrl}/api/history?limit=20`); // Limita as últimas 20 entradas
            const history = await response.json();
            const historyList = document.getElementById('actuatorHistoryList');
            historyList.innerHTML = ''; // Limpa a lista existente

            if (history && history.length > 0) {
                // Inverte a ordem para mostrar os mais recentes primeiro
                history.reverse().forEach(log => {
                    const p = document.createElement('p');
                    const timestamp = luxon.DateTime.fromISO(log.timestamp).toFormat('dd/MM HH:mm:ss');
                    p.textContent = `${timestamp} - ${log.actuator}: ${log.action} (${log.reason})`;
                    historyList.appendChild(p);
                });
            } else {
                historyList.innerHTML = '<p>Nenhum log de atuador disponível.</p>';
            }
        } catch (error) {
            console.error('Erro ao carregar histórico de atuadores:', error);
            document.getElementById('actuatorHistoryList').innerHTML = '<p>Erro ao carregar histórico.</p>';
        }
    }

    // Função para atualizar o status dos atuadores no dashboard baseado nos comandos WS
    function updateActuatorStatusDisplay(actuator, action) {
        let statusElement;
        let isOn = (action === 'on' || action === 'pulse1s'); // 'pulse1s' também é um estado 'ON' no momento do pulso

        switch (actuator) {
            case 'vent':
                statusElement = document.getElementById('ventStatus');
                break;
            case 'irrig':
                statusElement = document.getElementById('irrigStatus');
                break;
            case 'heat':
                statusElement = document.getElementById('lightStatus');
                break;
            default:
                return;
        }

        if (statusElement) {
            statusElement.textContent = isOn ? 'ON' : 'OFF';
            statusElement.className = isOn ? 'status-on' : 'status-off';
        }

        // Lógica especial para o pulso de irrigação para mostrar 'OFF' após 1s
        if (actuator === 'irrig' && action === 'on_pulse') { // Mudado de 'pulse1s' para 'on_pulse' (vindo do ESP32)
             setTimeout(() => {
                // Só desliga se não houver um novo comando ON no meio tempo
                if (irrigState === true) { // Verifique o estado global, se aplicável
                    statusElement.textContent = 'OFF';
                    statusElement.className = 'status-off';
                }
             }, 1000);
        }
        // Quando o ESP32 envia 'off_pulse' após o pulso, ele atualiza corretamente.
    }


    // WebSocket event handlers
    ws.onopen = () => {
      console.log('WebSocket Conectado!');
      ws.send(JSON.stringify({ type: 'register', role: 'dashboard' })); // Registra o dashboard
    };

    ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.type === 'paramsUpdate') {
        // Atualiza os parâmetros no dashboard se eles forem enviados pelo servidor (ex: após salvar)
        currentParams = msg.params;
        document.getElementById('tempThreshold').value = currentParams.tempThreshold;
        document.getElementById('minTempThreshold').value = currentParams.minTempThreshold;
        document.getElementById('humThreshold').value = currentParams.humThreshold;
        document.getElementById('soilThreshold').value = currentParams.soilThreshold;
        document.getElementById('autoControlToggle').checked = currentParams.autoControl;
        console.log('Parâmetros atualizados via WebSocket:', currentParams);
      } else if (msg.type === 'command') { // Se o servidor retransmitir comandos para outros dashboards
        // Isso é útil se vários dashboards estiverem conectados e um deles envia um comando.
        // O ESP32 também responde a esses comandos, então é principalmente para sincronização entre dashboards.
        updateActuatorStatusDisplay(msg.actuator, msg.action);
        console.log('Comando recebido via WS:', msg.actuator, msg.action);
      } else if (msg.type === 'actuatorStatus') { // Se o ESP32 enviar seu status via WS
        // Atualmente, o ESP32 envia logs via HTTP POST, mas se ele enviar status via WS no futuro, esta parte seria usada
        updateActuatorStatusDisplay(msg.actuator, msg.action);
        console.log('Status de atuador recebido via WS:', msg.actuator, msg.action);
      }
    };

    ws.onclose = () => {
      console.log('WebSocket Desconectado.');
    };

    ws.onerror = (error) => {
      console.error('Erro no WebSocket:', error);
    };

    // Função para alternar o tema
    const themeToggle = document.getElementById('themeToggle');
    function toggleTheme() {
      document.body.classList.toggle('light');
      const isLight = document.body.classList.contains('light');
      themeToggle.textContent = isLight ? 'Alternar para Tema Escuro' : 'Alternar para Tema Claro';
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
    }

    function loadTheme() {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'light') {
        document.body.classList.add('light');
        themeToggle.textContent = 'Alternar para Tema Escuro';
      }
    }
    themeToggle.addEventListener('click', toggleTheme);


    // Inicialização
    function init() {
      loadTheme();
      fetchData(); // Busca dados e atualiza o gráfico
      loadParams(); // Carrega parâmetros no formulário
      loadActuatorHistory(); // Carrega histórico de atuadores

      // Atualiza os dados dos sensores e o histórico a cada 30 segundos
      setInterval(fetchData, 30000);
      setInterval(loadActuatorHistory, 30000); // Atualiza o histórico a cada 30s
    }

    window.onload = init; // Inicia tudo quando a página é carregada
  </script>
</body>
</html>
